<!doctype html>
<html lang="en-us">
  <head>
    <title>cpp真有点吓人 // 不动闲心 の blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.89.4" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://1980204066.github.io/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="cpp真有点吓人"/>
<meta name="twitter:description" content="https://www.newsmth.net/nForum/#!article/CPlusPlus/403674
下面的英文是从教程里摘出来的。然后有点没看懂：make_unique 是cpp14引入的， 在这之前，下面叙述里的 foo 函数要怎么写才可以避免意外的内存泄露呢？ ------------------------------------------------------------- If your compiler does not yet support make_unique() , you can create your unique_ptr as follows. Note that Simple must be mentioned twice: unique_ptr&lt;Simple&gt; mySimpleSmartPtr(new Simple()); Before C&#43;&#43;17, you had to use make_unique() not only because you have to specify the type only once, but also because of safety reasons! Consider the following call to a function called foo() : foo(unique_ptr&lt;Simple&gt;(new Simple()), unique_ptr&lt;Bar&gt;(new Bar(data()))); If the constructor of Simple or Bar , or the data() function, throws an exception, depending on your compiler optimizations, it was very possible that either a Simple or a Bar object would be leaked."/>

    <meta property="og:title" content="cpp真有点吓人" />
<meta property="og:description" content="https://www.newsmth.net/nForum/#!article/CPlusPlus/403674
下面的英文是从教程里摘出来的。然后有点没看懂：make_unique 是cpp14引入的， 在这之前，下面叙述里的 foo 函数要怎么写才可以避免意外的内存泄露呢？ ------------------------------------------------------------- If your compiler does not yet support make_unique() , you can create your unique_ptr as follows. Note that Simple must be mentioned twice: unique_ptr&lt;Simple&gt; mySimpleSmartPtr(new Simple()); Before C&#43;&#43;17, you had to use make_unique() not only because you have to specify the type only once, but also because of safety reasons! Consider the following call to a function called foo() : foo(unique_ptr&lt;Simple&gt;(new Simple()), unique_ptr&lt;Bar&gt;(new Bar(data()))); If the constructor of Simple or Bar , or the data() function, throws an exception, depending on your compiler optimizations, it was very possible that either a Simple or a Bar object would be leaked." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://1980204066.github.io/2018/11/30/cpp%E7%9C%9F%E6%9C%89%E7%82%B9%E5%90%93%E4%BA%BA/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-11-30T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://1980204066.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>不动闲心 の blog</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">cpp真有点吓人</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 30, 2018
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://1980204066.github.io/tags/it/">it</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p><a href="https://www.newsmth.net/nForum/#!article/CPlusPlus/403674">https://www.newsmth.net/nForum/#!article/CPlusPlus/403674</a></p>
<p>下面的英文是从教程里摘出来的。然后有点没看懂：make_unique
是cpp14引入的， 
在这之前，下面叙述里的 foo 函数要怎么写才可以避免意外的内存泄露呢？ 
  
------------------------------------------------------------- 
If your compiler does not yet support make_unique() , you can  
create your unique_ptr as follows. Note that Simple must be mentioned
twice: 
  
     unique_ptr&lt;Simple&gt; mySimpleSmartPtr(new Simple()); 
  
Before C++17, you had to use make_unique() not only because you have to
specify  
the type only once, but also because of safety reasons! Consider the
following  
call to a function called foo() : 
  
     foo(unique_ptr&lt;Simple&gt;(new Simple()), unique_ptr&lt;Bar&gt;(new
Bar(data()))); 
  
If the constructor of Simple or Bar , or the data() function, throws an
exception, depending on
your compiler optimizations, it was very possible that either a Simple
or a Bar object would be
leaked. </p>
<p>按照后人的说法：</p>
<p>unique_ptr&lt;T&gt; t(new T())本身不危险</p>
<p>关键不在于一个对象产生的内存泄漏，c++不至于傻逼到ctor里面抛异常了连这个对象本身的内存都回收不了。这里的关键是传进去2个对象，当1个对象的ctor抛异常后能不能回收new另一个对象时候分配的内存。 
要点就是一旦new成功就立刻交给一个智能指针，这就是为啥要用make_unique</p>
<p>  </p>
<p>也就是说 A* p=new
A(); 如果A()抛出异常的话，那么p=null. 即对象本身的内存回收了。</p>
<p>关键在于gcc 的优化，foo(unique_ptr&lt;Simple&gt;(new Simple()),
unique_ptr&lt;Bar&gt;(new Bar(data()))); </p>
<p>可以变成： </p>
<p>new Simple()</p>
<p>new Bar(data())</p>
<p>unique_ptr&lt;Simple&gt;</p>
<p>unique_ptr&lt;Bar&gt;</p>
<p>只能说是悲剧的gcc，太害人了。</p>
<p>refer: https://blog.csdn.net/u011475134/article/details/76714243</p>
<p>refer: https://blog.csdn.net/Jxianxu/article/details/72859800?utm_source=blogxgwz0</p>
<p>有点意思，后人演示代码： 对于make_unique处理不了的private
ctor，就只能由factory method直接返回unique_ptr</p>
<p>你可以直接点run看运行结果： 
 </p>
<blockquote>
<p>allocate 4 bytes at 0x1616c20
throw exception
free 0x1616c20
allocate 4 bytes at 0x1616c20
allocate 4 bytes at 0x1617050
throw exception
free 0x1617050
free 0x1616c20
allocate 4 bytes at 0x1616c20
throw exception
free 0x1616c20</p>
</blockquote>
<p>没有内存泄露。 
  
刚发现你是不是连主贴里讨论的东西都没看明白？ 
关键不在于一个对象产生的内存泄漏，c++不至于傻逼到ctor里面抛异常了连这个对象本身的内存都回收不了。这里的关键是传进去2个对象，当1个对象的ctor抛异常后能不能回收new另一个对象时候分配的内存。 
要点就是一旦new成功就立刻交给一个智能指针，这就是为啥要用make_unique
对于make_unique处理不了的private ctor，就只能由factory
method直接返回unique_ptr
  
全部代码： </p>
<blockquote>
<p>#include &lt;memory&gt; 
#include &lt;iostream&gt; 
using namespace std; 
  
template &lt;bool Exception&gt; 
class A { 
  public: 
   static unique_ptr&lt;A&gt; Create()  { 
     unique_ptr&lt;A&gt; p(new A); 
     return p; 
   } 
  
   void* operator new(size_t size) { 
     void* p = malloc(size); 
     cout &lt;&lt; &quot;allocate &quot; &lt;&lt; size &lt;&lt; &quot; bytes at &quot; &lt;&lt; p &lt;&lt;
endl; 
     return p; 
   } 
  
   void operator delete(void* p) { 
     cout &lt;&lt; &quot;free &quot; &lt;&lt; p &lt;&lt; endl; 
     free(p); 
   } 
  
  private: 
   A() { 
     if (Exception) { 
       cout &lt;&lt; &quot;throw exception\n&quot;; 
       throw 0; 
     } 
   } 
  
   int date; 
}; 
  
template &lt;class First, class Second&gt; 
void Foo(unique_ptr&lt;First&gt; first, unique_ptr&lt;Second&gt; second) { } 
  
int main() { 
   try { 
     auto p = A&lt;true&gt;::Create(); 
   } catch (...) {} 
  
   try { 
     Foo(A&lt;true&gt;::Create(), A&lt;false&gt;::Create()); 
   } catch (...) {} 
  
   try { 
     Foo(A&lt;false&gt;::Create(), A&lt;true&gt;::Create()); 
   } catch (...) {} 
} </p>
</blockquote>
<p>  </p>
<p>附录： https://blog.csdn.net/u011475134/article/details/76714243 
智能指针之make_unique与make_shared</p>
<p>make_unique的实现</p>
<p>std::make_shared是C++11的一部分，但是std::make_unique很可惜不是。它是在C++14里加入标准库的，但我们可以自己实现make_unique方法。</p>
<p>// 支持普通指针</p>
<p>template&lt;class T,class... Args&gt; inline</p>
<p>typename enable_if&lt;!is_array&lt;T&gt;::value,unique_ptr&lt;T&gt;&gt;::type</p>
<p>make_unique(Args&amp;&amp;... args){</p>
<p>    return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</p>
<p>}</p>
<p>// 支持动态数组</p>
<p>template&lt;class T&gt; inline</p>
<p>typename enable_if&lt;is_array&lt;T&gt;::value &amp;&amp; extent&lt;T&gt;::value ==
0,unique_ptr&lt;T&gt;&gt;::type</p>
<p>make_unique(size_t size){</p>
<p>    typedef typename remove_extent&lt;T&gt;::type U;</p>
<p>    return unique_ptr&lt;T&gt;(new U[size]());</p>
<p>}</p>
<p>// 过滤掉定长数组的情况</p>
<p>template&lt;class T,class... Args&gt;</p>
<p>typename enable_if&lt;extent&lt;T&gt;::value != 0,void&gt;::type</p>
<p>make_unique(Args&amp;&amp;...) = delete;</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>enable_if的作用</p>
<p>// Primary template.</p>
<p>/// Define a member typedef @c type only if a boolean constant is true.</p>
<p>template&lt;bool, typename _Tp = void&gt;</p>
<p>  struct enable_if</p>
<p>  { };</p>
<p>// Partial specialization for true.</p>
<p>template&lt;typename _Tp&gt;</p>
<p>  struct enable_if&lt;true, _Tp&gt;</p>
<p>  { typedef _Tp type; };</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>结合源码可知，当condition==true时，enable_if&lt;condition,T&gt;::type ≡
T，否则报错。</p>
<p>enable_if&lt;!is_array&lt;T&gt;::value,unique_ptr&lt;T&gt;&gt;::type的condition在T不是数组类型时为true</p>
<p>enable_if&lt;is_array&lt;T&gt;::value &amp;&amp; extent&lt;T&gt;::value ==
0,unique_ptr&lt;T&gt;&gt;::type的condition在T为数组类型且数组中元素个数为0时为true，由于对于非数组类型extent&lt;U&gt;::value也为0，语句is_array&lt;T&gt;::value是必要的</p>
<p>enable_if&lt;extent&lt;T&gt;::value !=
0,void&gt;::type的condition在T类型中元素个数不为0时为true，即T为定长数组</p>
<p>std::forward的作用</p>
<p>std::forward在这里的作用是实现参数的完美转发，具体见《move和forward源码分析[转]》。</p>
<p>make函数的好处</p>
<p>1. 效率更高</p>
<p>shared_ptr需要维护引用计数的信息。如果你通过使用原始的new表达式分配对象，然后传递给shared_ptr（也就是使用shared_ptr的构造函数）的话，shared_ptr的实现没有办法选择，而只能单独的分配控制块：</p>
<p>如果选择使用make_shared的话，情况就会变成下面这样：</p>
<p>内存分配的动作，可以一次性完成。这减少了内存分配的次数，而内存分配是代价很高的操作。</p>
<p>2. 异常安全</p>
<p>看看下面的代码：</p>
<p>void F(const std::shared_ptr&lt;Lhs&gt;&amp; lhs, const std::shared_ptr&lt;Rhs&gt;&amp;
rhs) { /* ... */ }</p>
<p>F(std::shared_ptr&lt;Lhs&gt;(new Lhs(&quot;foo&quot;)),</p>
<p>  std::shared_ptr&lt;Rhs&gt;(new Rhs(&quot;bar&quot;)));</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>C++是不保证参数求值顺序，以及内部表达式的求值顺序的，所以可能的执行顺序如下：</p>
<p>new Lhs(&ldquo;foo&rdquo;))</p>
<p>new Rhs(&ldquo;bar&rdquo;))</p>
<p>std::shared_ptr</p>
<p>std::shared_ptr</p>
<p>假设在第2步的时候，抛出了一个异常（比如out of
memory，总之，Rhs的构造函数异常了），那么第一步申请的Lhs对象内存泄露了。这个问题的核心在于，shared_ptr没有立即获得裸指针。</p>
<p>我们可以用如下方式来修复这个问题：</p>
<p>auto lhs = std::shared_ptr&lt;Lhs&gt;(new Lhs(&quot;foo&quot;));</p>
<p>auto rhs = std::shared_ptr&lt;Rhs&gt;(new Rhs(&quot;bar&quot;));</p>
<p>F(lhs, rhs);</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>当然，推荐的做法是使用std::make_shared来代替：</p>
<p>F(std::make_shared&lt;Lhs&gt;(&quot;foo&quot;), std::make_shared&lt;Rhs&gt;(&quot;bar&quot;));</p>
<p>1</p>
<p>当std::make_shared被调用，指向动态内存对象的原始指针会被安全的保存在返回的std::shared_ptr对象中，然后另一std::make_shared被调用。如果此时产生了异常，那std::shared_ptr析构会知道于是它所拥有的对象会被销毁。</p>
<p>使用std::make_unique来代替new在写异常安全的代码里和使用std::make_shared一样重要。</p>
<p>make函数的不足</p>
<p>make函数都不允许使用定制删除器，但是std::unique_ptr和std::shared_ptr的构造函数都可以。</p>
<p>make函数不能完美传递一个initializer_list。 </p>
<p>替代方案：</p>
<p>// initializer_list&lt;int&gt; aa = {1,2,3}; // 或者</p>
<p>auto aa = {1,2,3};</p>
<p>auto a = make_shared&lt;vector&lt;int&gt;&gt;(aa);</p>
<p>// auto b = make_shared&lt;vector&lt;int&gt;&gt;({1,2,3}); // 错误</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>对象的内存可能无法及时回收</p>
<p>虽然使用std::make_shared可以减少了内存分配的次数，提高效率，但由于控制块与对象都在同一块动态分配的内存上，所以当对象的引用计数变为0，对象被销毁（析构函数被调）后，该对象所占内存仍未释放，直到控制块同样也被销毁，内存才会释放。</p>
<p>我们知道，在控制块中包含两个计数：shared count和weak
count，分别表示std::shared_ptr和std::weak_ptr对对象的引用计数，只有当shared
count和weak count都为0时，控制块才会被销毁。</p>
<p>换句话说，只要有std::weak_ptr指向一个控制块（weak
count大于0），那控制块就一定存在。只要控制块存在，包含它的内存必定存在。通过std::shared_ptr的make函数分配的内存在最后一个std::shared_ptr和最后一个std::weak_ptr被销毁前不能被释放。</p>
<p>构造函数是保护或私有时，无法使用make_shared。 </p>
<p>替代方案：</p>
<p>class A {</p>
<p>public:</p>
<p>    static std::shared_ptr&lt;A&gt; create() {</p>
<p>        return std::make_shared&lt;A&gt;();</p>
<p>    }</p>
<p>protected:</p>
<p>    A() {}</p>
<p>    A(const A &amp;) = delete;</p>
<p>    const A &amp;operator=(const A &amp;) = delete;</p>
<p>};</p>
<p>std::shared_ptr&lt;A&gt; foo() {</p>
<p>    return A::create();</p>
<p>}</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>参考链接</p>
<p>--------------------- </p>
<p>作者：SigalHu</p>
<p>来源：CSDN </p>
<p>原文：https://blog.csdn.net/u011475134/article/details/76714243 </p>
<p>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<p>refer： <a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">When is std::weak_ptr
useful?</a></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
