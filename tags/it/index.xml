<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>it on 不动闲心 の blog</title>
    <link>https://1980204066.github.io.git/tags/it/</link>
    <description>Recent content in it on 不动闲心 の blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://1980204066.github.io.git/tags/it/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>编译kernel</title>
      <link>https://1980204066.github.io.git/2019/12/04/%E7%BC%96%E8%AF%91kernel/</link>
      <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/12/04/%E7%BC%96%E8%AF%91kernel/</guid>
      <description>How to compile and install Linux Kernel 5.1.2 from source code
下载 linux-5.4.1
cp /boot/config-5.3.13-300.fc31.x86_64 linux-5.4.1/.config
make xconfig 或者 (defconfig, oldconfig, config, gconfig)
make -j 4
sudo make modules_install
sudo make install
sudo grubby --set-default /boot/vmlinuz-5.1.2 #安装自己定义的名称来设置
生成tag
gtags -v
htags -DfFnva -t &#39;kernel 5.4.1 Ref&#39;
htags-server # 默认https://127.0.0.1:8000</description>
    </item>
    
    <item>
      <title>备份邮箱的脚本</title>
      <link>https://1980204066.github.io.git/2019/09/25/%E5%A4%87%E4%BB%BD%E9%82%AE%E7%AE%B1%E7%9A%84%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/09/25/%E5%A4%87%E4%BB%BD%E9%82%AE%E7%AE%B1%E7%9A%84%E8%84%9A%E6%9C%AC/</guid>
      <description>https://www.newsmth.net/nForum/#!article/Python/152831
# -*- coding: utf-8 -*- import os import requests from lxml import html headers = { &amp;#39;Host&amp;#39;: &amp;#39;m.newsmth.net&amp;#39;, &amp;#39;Accept-Language&amp;#39;: &amp;#39;zh-CN,zh;q=0.8,en;q=0.6&amp;#39;, &amp;#39;Connection&amp;#39;: &amp;#39;keep-alive&amp;#39;, &amp;#39;Pragma&amp;#39;: &amp;#39;no-cache&amp;#39;, &amp;#39;Cache-Control&amp;#39;: &amp;#39;no-cache&amp;#39;, &amp;#39;Upgrade-Insecure-Requests&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;Accept&amp;#39;: &amp;#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&amp;#39;, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) &amp;#39; &amp;#39;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&amp;#39;, &amp;#39;Cookie&amp;#39;: &amp;#39;你的cookei&amp;#39; } def save(text, filename=&amp;#39;temp&amp;#39;, path=&amp;#39;outbox&amp;#39;): fpath = os.path.join(path, filename) with open(fpath, &amp;#39;wb&amp;#39;) as f: print(&amp;#39;output:&amp;#39;, fpath) f.write(text) def save_letter(letter_url): resp = requests.get(&amp;#39;https://m.newsmth.net&amp;#39;+letter_url,headers=headers) page = resp.</description>
    </item>
    
    <item>
      <title>python3的lxml</title>
      <link>https://1980204066.github.io.git/2019/09/24/python3%E7%9A%84lxml/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/09/24/python3%E7%9A%84lxml/</guid>
      <description>lxml 学习笔记
如果某个属性的值有多个时，我们可以使用contains()函数来获取
result1=html.xpath(&#39;//li[contains(@class,&amp;quot;aaa&amp;quot;)]/a/text()&#39;)
同时匹配多个属性，此时可用运用and运算符来连接
result1=html.xpath(&#39;//li[contains(@class,&amp;quot;aaa&amp;quot;) and @name=&amp;quot;fore&amp;quot;]/a/text()&#39;)
https://stackoverflow.com/questions/7474972/python-lxml-append-element-after-another-element
contentdiv = contentnav.getparent()
https://stackoverflow.com/questions/23282241/lxml-difference-between-element-addnext-and-insert-in-handling-tail
xml[0].tail.find(&amp;quot;italic&amp;quot;)</description>
    </item>
    
    <item>
      <title>GitHub网页githubusercontent地址访问</title>
      <link>https://1980204066.github.io.git/2019/09/22/githubusercontent/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/09/22/githubusercontent/</guid>
      <description>ref: https://zhuanlan.zhihu.com/p/107691233
hosts文件内容如下：
# 2020年12月30日更新 # GitHub Start 52.74.223.119 github.com 52.74.223.119 gist.github.com 54.169.195.247 api.github.com 185.199.111.153 assets-cdn .github.com 199.232.96.133 raw.githubusercontent.com 199.232.96.133 gist.githubusercontent.com 199.232.96.133 cloud.githubusercontent.com 199.232.96.133 camo.githubusercontent.com 199.232.96.133 avatars0.githubusercontent.com 199.232.96.133 avatars1.githubusercontent.com 199.232.96.133 avatars2.githubusercontent.com 199.232.96.133 avatars3.githubusercontent.com 199.232.96.133 avatars4.githubusercontent.com 199.232.96.133 avatars5.githubusercontent.com 199.232.96.133 avatars6.githubusercontent.com 199.232.96.133 avatars7.githubusercontent.com 199.232.96.133 avatars8.githubusercontent.com 199.232.96.133 user-images.githubusercontent.com 185.199.109.154 github.githubassets.com # GitHub End 然后 sudo systemctl restart NetworkManager.service 不用可能也可以。
ping raw.githubusercontent.com</description>
    </item>
    
    <item>
      <title>文字方向</title>
      <link>https://1980204066.github.io.git/2019/09/21/%E6%96%87%E5%AD%97%E6%96%B9%E5%90%91/</link>
      <pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/09/21/%E6%96%87%E5%AD%97%E6%96%B9%E5%90%91/</guid>
      <description>g++ -std=c++0x test.c
#include &amp;lt;string&amp;gt;#include &amp;lt;codecvt&amp;gt;#include &amp;lt;locale&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;stdio.h&amp;gt;#define WIDGTH 16 using namespace std; // utf8转unicode wstring utf8_to_wstring(const string &amp;amp;str) { wstring_convert&amp;lt;codecvt_utf8&amp;lt;wchar_t&amp;gt;&amp;gt; utf8_cvt; return utf8_cvt.from_bytes(str); } // unicode转utf8 string wstring_to_utf8(const wstring &amp;amp;str) { wstring_convert&amp;lt;codecvt_utf8&amp;lt;wchar_t&amp;gt;&amp;gt; utf8_cvt; return utf8_cvt.to_bytes(str); } static wstring wstart = utf8_to_wstring(u8&amp;#34;←&amp;#34;); static wstring LR = utf8_to_wstring(u8&amp;#34;\n&amp;#34;); static wstring brackets = utf8_to_wstring(&amp;#34;〈〉《》「」『』【】〔〕（）()&amp;#34;); int main(int argc, char **argv) { int nwords = 0; /* wcout.imbue(locale(&amp;#34;zh_CN.GBK&amp;#34;)); */ int has_num = 0; wstring wline = wstart; auto add_num = [&amp;amp;](wstring&amp;amp; wsequence) { if (has_num) { nwords += has_num, has_num = 0; wline = wsequence + wline, wsequence.</description>
    </item>
    
    <item>
      <title>is_base_of</title>
      <link>https://1980204066.github.io.git/2019/08/23/is_base_of/</link>
      <pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/08/23/is_base_of/</guid>
      <description>明白了就看看这个 is_base_of namespace details { template &amp;lt;typename Base&amp;gt; std::true_type is_base_of_test_func(const volatile Base*); template &amp;lt;typename Base&amp;gt; std::false_type is_base_of_test_func(const volatile void*); template &amp;lt;typename Base, typename Derived&amp;gt; using pre_is_base_of = decltype(is_base_of_test_func&amp;lt;Base&amp;gt;(std::declval&amp;lt;Derived*&amp;gt;())); // with &amp;lt;experimental/type_traits&amp;gt;: // template &amp;lt;typename Base, typename Derived&amp;gt; // using pre_is_base_of2 = std::experimental::detected_or_t&amp;lt;std::true_type, pre_is_base_of, Base, Derived&amp;gt;; template &amp;lt;typename Base, typename Derived, typename = void&amp;gt; struct pre_is_base_of2 : public std::true_type { }; // note std::void_t is a C++17 feature template &amp;lt;typename Base, typename Derived&amp;gt; struct pre_is_base_of2&amp;lt;Base, Derived, std::void_t&amp;lt;pre_is_base_of&amp;lt;Base, Derived&amp;gt;&amp;gt;&amp;gt; : public pre_is_base_of&amp;lt;Base, Derived&amp;gt; { }; } template &amp;lt;typename Base, typename Derived&amp;gt; struct is_base_of : public std::conditional_t&amp;lt; std::is_class&amp;lt;Base&amp;gt;::value &amp;amp;&amp;amp; std::is_class&amp;lt;Derived&amp;gt;::value, details::pre_is_base_of2&amp;lt;Base, Derived&amp;gt;, std::false_type &amp;gt; { }; https://stackoverflow.</description>
    </item>
    
    <item>
      <title>use-package专题</title>
      <link>https://1980204066.github.io.git/2019/08/17/use-package%E4%B8%93%E9%A2%98/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/08/17/use-package%E4%B8%93%E9%A2%98/</guid>
      <description>Table of Contents  package的引入和管理 Eval after load use-package manual 暴增 Emacs 生产力的十大最佳插件 emacs操作 - 插件篇 超简单emacs配置 emacs配置 How to exclude files from Projectile?  package的引入和管理 Auto-loading 可以向emacs中注册一个函数，只有当调用或者使用这个函数的时候，包含这个函数的文件才会加载。这么用：
(autoload&amp;rsquo;some-function”some-file”)
当调用some-function 时，加载some-file.el，再执行这个函数。autoload完整参数：
(autoload FUNCTION FILE &amp;amp;optional DOCSTRING INTERACTIVE TYPE)，
可以看出它除了提供加载文件地址外，还可以编写说明文档，在不加载文件时也能够查看它的用法。
autoload这种方法可以写入的到emacs配置文件里面，但明显不好管理，为什么不在函数定义处就指明它是一个autoload形式的函数呢？事实上可以用所谓的”魔术”注释来装饰一个函数的开头，让它autoload。 ~ elisp ;;;###autoload (defun my-function () ;; Source code… ) ~ ;;;###autoload是一种神奇的注释。当然autoload这种机制不局限于函数，可以用在一切可以定义的东西上面，比如宏、主模式、次模式等等。
类似c++的虚函数，先在symbol的位置放上autoloader, 实际使用是动态载入实际的函数。？？
Eval after load 当我们加载一个package的时候想配置它，比如绑定一个自定义的函数等等。为了能够让我们的自定义的代码也autoload，使用with-eval-after-load。
(with-eval-after-load &#39;helm ;; Some-Code )  Use-package是一个第三方的package，使用前需要安装。Use-package可以说是为了解决之前提到的所有问题而出现的。Use-package是一个宏，来看看它是怎么使用的：
(use-package helm :defer t))
:defer是个关键字，如果为t，则表示helm的里面的凡是被autoload的函数、宏、模式等都成立。 ~ elisp (use-package helm :defer t :init ;; Code to execute before Helm is loaded :config ;; Code to execute after Helm is loaded ) ~ 关键字:init和:config，顾名思义，针对package加载之前和package加载之后添加一些自己的配置。在:init中可以加载一些入口设定，比如定义一些按键调用这个package里面的函数。:config关键字后面的代码和with-eval-after-load功用是一样的，都是package实际被加载之后才会执行。use-package还有很多关键字，比如指定某些条件下才会加载package，可以指定某些特定文件才加载这个package，可以进官方文档自行查看。</description>
    </item>
    
    <item>
      <title>elisp基础与示例</title>
      <link>https://1980204066.github.io.git/2019/08/13/elisp%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/08/13/elisp%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%A4%BA%E4%BE%8B/</guid>
      <description>Table of Contents  lisp基础知识  lisp求值 elisp函数中的quote lisp谓词eq,eql,equal   lisp构想例  读取url让firefox打开 去掉list重复项目 删除list中的一项 求全组合    lisp基础知识 lisp求值 求值是 lisp 解释器的核心，理解了求值过程也就学会了 lisp 编程的一半。一个symbol可以同时指代变量和函数，就是说一个foo，即是变量，又是 函数，在lisp里面是合法的。
(defun foo (x) (* x x)) (setq foo 5) (foo foo)  一个要求值的 lisp对象被称为表达式（form）。所有的表达式可以分为三种： 符号、列表和其它类型（废话）。
  自求值表达式。前面说过数字、字符串、向量都是自求值表达式。还有两个特殊的符号
t 和 nil
也可以看成是自求值表达式。最特别的是，()求值返回nil，因为()和 nil根本就是一回事情。
  符号的求值结果就是符号的值。如果它没有值，就会出现void-variable 的错误。
  列表表达式。而列表表达式又可以根据第一个元素分为函数调用 、宏调用和特殊表达式（special form）三种。列表的第一个表达式如果是一个 符号，解释器会查找这个表达式的*函数值*。如果函数值是另一个符号，则会继续 查找这个符号的函数值。这称为”symbol function indirection”。最后直到某 个符号的函数值是一个 lisp 函数（lambda 表达式）、byte-code 函数、原子函数（primitive function）、宏、特殊表达式或 autoload对象。如果不是这 些类型，比如某个符号的函数值是前面出现的某个符号导致无限循环，或者某个 符号函数值为空，都会导致一个错误invalid-function。</description>
    </item>
    
    <item>
      <title>emacs-配置帮助</title>
      <link>https://1980204066.github.io.git/2019/08/11/emacs-%E9%85%8D%E7%BD%AE%E5%B8%AE%E5%8A%A9/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/08/11/emacs-%E9%85%8D%E7%BD%AE%E5%B8%AE%E5%8A%A9/</guid>
      <description>Table of Contents  Key Bind Commands global-set-key 干了什么 绑定中文命令 Custom Prefixes Emacs中`global-set-key`和`define-key global-map`有什么区别 使用add-hook给指定的主模式绑定按键 使用define-key给指定的模式绑定按键 M-x global-set-key RET 交互式的绑定你的键 Duplicating prefix keys 如何把find-file绑定到M-o emacs使用ggtags my dot emacs Emacs M$ 系统下特别慢  Key Bind Commands There are several ways you can define (or undefine) keys, as the table below shows, but in reality there are dozens of ways you can hack the keymaps.
(define-key KEYMAP KEY DEF)
Defines a key against a keyboard map.</description>
    </item>
    
    <item>
      <title>gnome-termilalfont</title>
      <link>https://1980204066.github.io.git/2019/08/10/gnome-termilalfont/</link>
      <pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/08/10/gnome-termilalfont/</guid>
      <description>cp /mnt/d/Windows/Fonts/simsun.ttf ~/.fonts
fc-cache
sudo fc-cache -fv .fonts (.fonts为你的字体目)
fc-list
gnome-terminal
screenshot
{smallsrc=&amp;ldquo;https://imglf3.lf127.net/img/TE0ySjlkTnYxRnRCM05JTVlma1djV0ZSaEVSaEhvdk11b0pUeEp4cmZ5L2ZVRnoyUlRxOEJnPT0.png?=imageView&amp;amp;thumbnail=164x164&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg%7Cwatermark&amp;amp;type=2&amp;quot; style=&amp;ldquo;max-width:500px;&amp;quot;}</description>
    </item>
    
    <item>
      <title>Linux下升级gcc版本9.1.0版本</title>
      <link>https://1980204066.github.io.git/2019/08/10/Linux%E4%B8%8B%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC9.1.0%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2019/08/10/Linux%E4%B8%8B%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC9.1.0%E7%89%88%E6%9C%AC/</guid>
      <description>https://mamicode.com/info-detail-2688872.html
wget https://ftp.gnu.org/gnu/gcc/gcc-9.1.0/gcc-9.1.0.tar.gz
tar -xzvf gcc-9.1.0.tar.gz
cd gcc-9.1.0
./contrib/download_prerequisiles
mkdir ../build-gcc
cd ../build-gcc/
../gcc-9.1.0/configure --enable-bootstrap --enable-languages=c,c++ --prefix=/tools --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --enable-plugin --enable-initfini-array --with-isl --enable-libmpx --enable-offload-targets=nvptx-none --without-cuda-driver --enable-gnu-indirect-function --enable-cet --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux
这个不行啊。
../gcc-9.1.0/configure -enable-checking=release -prefix=/tools -enable-languages=c,c++ -disable-multilib
https://blog.csdn.net/sonicling/article/details/6706152
而GCC的词法分析是手工构造的，实现在libcpp/lex.c文件中，其中最重要的那个函数是_cpp_lex_direct，他反应了GCC词法分析器的核心结构。
$ cat t2.c #include &amp;lt;stdio.h&amp;gt; int main(int argc, char **argv) { int i ← 0; unsigned char *str ← &amp;quot;1234中&amp;quot;; while(str[i]) { printf(&amp;quot;%02x &amp;quot;,str[i]); i++; } printf(&amp;quot;\n&amp;quot;); if ( 1 ?</description>
    </item>
    
    <item>
      <title>2019 07 24 Cache一致性和内存模型</title>
      <link>https://1980204066.github.io.git/posts/2019-07-24-cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/posts/2019-07-24-cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>Cache一致性和内存模型   https://wudaijun.com/2019/04/cpu-cache-and-memory-model/
 本文主要谈谈CPU Cache的设计，内存屏障的原理和用法，最后简单聊聊内存一致性。
 我们都知道存储器是分层级的，从CPU寄存器到硬盘，越靠近CPU的存储器越小越快，离CPU越远的存储器越大但越慢，即所谓存储器层级(Memory Hierarchy)。以下是计算机内各种存储器的容量和访问速度的典型值。
 从广义的概念上来说，所有的存储器都是其下一级存储器的Cache，CPU Cache缓存的是内存数据，内存缓存的是硬盘数据，而硬盘缓存的则是网络中的数据。本文只谈CPU Cache，一个简单的CPU Cache示意图如下:
  图中忽略了一些细节，现代的CPU Cache通常分为三层，分别叫L1,L2,L3 Cache, 其中L1,L2 Cache为每个CPU核特有，L3为所有CPU核共有，L1还分为缓存指令的i-cache(只读)和缓存程序数据的d-cache，L2 L3 Cache则不区分指令和程序数据，称为统一缓存(unified cache)。本文主要讨论缓存命中和缓存一致性的问题，因此我们只关注L1 Cache，不区分指令缓存和程序数据缓存。
Cache Geometry   当CPU加载某个地址上的数据时，会从Cache中查找，Cache由多个Cache Line构成(通常L1 Cache的Cache Line大小为64字节)，因此目标地址必须通过某种转换来映射对应的Cache Line，我们可以很容易想到两种方案:
  指定地址映射到指定Cache Line，读Cache时对地址哈希(通常是按照Cache Line数量取模，即在二进制地址中取中间位)来定位Cache Line，写Cache时如果有冲突则丢掉老的数据。这种策略叫*直接映射*
  任何地址都可以映射到任何Cache Line，读Cache时遍历所有Cache Line查找地址，写Cache时，可以按照LFU(最不常使用)或LRU(最近最少使用)等策略来替换。这种策略叫*全相联*
  直接映射的缺点在于在特定的代码容易发生冲突不命中，假设某CPU Cache的Cache Line大小为16字节，一共2个Cache Line，有以下求向量点乘的代码:
 由于x和y在函数栈中是连续存放的，x[0..3]和y[0..3]将映射到同一个Cache Line, x[4..7]和y[4..7]被映射到同一个Cache Line，那么在for循环一次读取x[i],y[i]的过程中，Cache Line将不断被冲突替换，导致Cache &amp;#34;抖动&amp;#34;(thrashing)。也就是说，在直接映射中，即使程序看起来局部性良好，也不一定能充分利用Cache。
 那么同样的例子，换成全相联，则不会有这个问题，因为LRU算法会使得y[0..3]不会替换x[0..3]所在的Cache Line，也就不会造成Cache抖动。全相连的缺点是由于每一次读Cache都需要遍历所有的Cache Line进行地址匹配，出于效率考虑，它不适用于太大的Cache。
 So，现代OS的操作系统是取两者折中，即组相连结构: 将若干Cache Line分为S个组，组间直接映射，组内全相连，如下图:
  通用的Cache映射策略，将目标地址分为t(标记位)，s(组索引)，b(块偏移)三个部分。我在Linux Perf 简单试用中也有例子说明程序局部性对效率的影响。</description>
    </item>
    
    <item>
      <title>自动mountntfs</title>
      <link>https://1980204066.github.io.git/2018/12/16/%E8%87%AA%E5%8A%A8mountntfs/</link>
      <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/12/16/%E8%87%AA%E5%8A%A8mountntfs/</guid>
      <description>/etc/fstab
UUID=&amp;quot;60CA0B46CA0B17C4&amp;quot; /mnt/lenovo ntfs defaults,noauto,user,exec 0 0
ntfs-3g 需要一些设置： https://www.tuxera.com/community/ntfs-3g-faq/#useroption
Why do I get &amp;ldquo;fusermount: option blkdev is privileged&amp;rdquo; error?
Unprivileged block device mounts work only if all the below requirements are met:
  ntfs-3g is compiled with integrated FUSE support
  the ntfs-3g binary is at least version 1.2506
  the ntfs-3g binary is set to setuid-root
  the user has access right to the volume</description>
    </item>
    
    <item>
      <title>Firefox浏览器插件</title>
      <link>https://1980204066.github.io.git/posts/2018-12-09-firefox%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/posts/2018-12-09-firefox%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</guid>
      <description>Tampermonkey   http://www.cnplugins.com/zhuanti/tampermonkey-userscript-recommend.html
   Tampermonkey自用脚本推荐百度网盘直接下载助手 https://greasyfork.org/zh-CN/scripts/23635       解决百度云大文件下载限制 https://greasyfork.org/zh-CN/scripts/17800       优化百度-搜狗-谷歌搜索结果之重定向去除-去广告 https://greasyfork.org/zh-CN/scripts/14178       Tampermonkey自用脚本推荐百度网盘直接下载助手 https://greasyfork.org/zh-CN/scripts/23635       解决百度云大文件下载限制 https://greasyfork.org/zh-CN/scripts/17800       优化百度-搜狗-谷歌搜索结果之重定向去除-去广告 https://greasyfork.org/zh-CN/scripts/14178       知乎免登陆 https://greasyfork.org/zh-CN/scripts/6489       vip视频在线解析 https://greasyfork.org/zh-CN/scripts/27349       网页强制复制 https://greasyfork.</description>
    </item>
    
    <item>
      <title>IDM下载器</title>
      <link>https://1980204066.github.io.git/2018/12/08/IDM%E4%B8%8B%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/12/08/IDM%E4%B8%8B%E8%BD%BD%E5%99%A8/</guid>
      <description>IDM下载器使用方法详解 https://chromecj.com/utilities/2018-11/1666.html 通过IDM下载百度云的资源 https://blog.csdn.net/dajitui2024/article/details/79396662 Tampermonkey Chrome插件下载 估计可以在这找到: https://www.cnplugins.com/office/tampermonkey/download.html
百度网盘直接下载助手 直链加速版 https://greasyfork.org/zh-CN/scripts/39504-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E7%9B%B4%E9%93%BE%E5%8A%A0%E9%80%9F%E7%89%88
2018-11-13 : v1.3.3 修复脚本失效的问题, 请登录后使用
2018-10-31 : v1.3.2 修复脚本失效的问题, 网盘里文件必须分享文件后使用
重要事情说三遍所有文件请分享后使用
重要事情说三遍所有文件请分享后使用
重要事情说三遍所有文件请分享后使用
IDM+百度网盘助手 https://blog.csdn.net/sinat_31428707/article/details/80949476
通过IDM下载百度云的资源201709 https://blog.csdn.net/dajitui2024/article/details/79396662</description>
    </item>
    
    <item>
      <title>网盘</title>
      <link>https://1980204066.github.io.git/2018/12/06/%E7%BD%91%E7%9B%98/</link>
      <pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/12/06/%E7%BD%91%E7%9B%98/</guid>
      <description>百度云上还有一个空间,用手机号登陆 https://yun.baidu.com/ 包括一些winpe
pan.baidu.com 有2个,用 gmail帐号登陆. 手机号一个空的.
2016.12.20.FBA完整版.7z:
https://pan.baidu.com/s/1-0q4kK3JWWP6KM-UQxPK3A
自用系统安装维护用Win10PE 2in1一枚 https://bbs.wuyou.net/forum.php?mod=viewthread&amp;amp;tid=410320&amp;amp;extra=page%3D2
包括pe编辑工具。
https://pan.baidu.com/s/1RytqHy-_IEaBtHHT-pIb8g密码:tdsq</description>
    </item>
    
    <item>
      <title>linux安装Steam</title>
      <link>https://1980204066.github.io.git/2018/12/05/linux%E5%AE%89%E8%A3%85Steam/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/12/05/linux%E5%AE%89%E8%A3%85Steam/</guid>
      <description>https://negativo17.org/steam/
 dnf config-manager --add-repo=https://negativo17.org/repos/fedora-steam.repo
 To make &amp;ldquo;Big Picture&amp;rdquo; work in Fedora or CentOS/RHEL, enable this SELinux boolean as root:
 setsebool -P allow_execheap 1
 英雄无敌3地图的中英文对照 
英雄无敌3死亡阴影怎么知道地图对应的英文名称
英雄无敌3开源引擎vcmi的编译安装
How to build VCMI (Linux) https://wiki.vcmi.eu/How_to_build_VCMI_(Linux)
sudo yum install cmake gcc-c++ SDL2-devel SDL2_image-devel SDL2_ttf-devel SDL2_mixer-devel boost boost-devel boost-filesystem boost-system boost-thread boost-program-options boost-locale zlib-devel ffmpeg-devel ffmpeg-libs qt5-qtbase-devel
 mkdir build &amp;amp;&amp;amp; cd build cmake ../vcmi
cmake --build . -- -j2</description>
    </item>
    
    <item>
      <title>smbclient</title>
      <link>https://1980204066.github.io.git/2018/12/05/smbclient/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/12/05/smbclient/</guid>
      <description>win7下先share目录ISO
Linux：
smbclient -L 192.168.1.101
  Sharename Type Comment --------- ---- ------- ADMIN$ Disk 远程管理 C$ Disk 默认共享 D$ Disk 默认共享 IPC$ IPC 远程 IPC ISO-ghost Disk  smbclient //192.168.1.101/ISO-ghost -U username%password
 Enter SAMBA\gsdj&#39;s password: Try &amp;quot;help&amp;quot; to get a list of possible commands. smb: \&amp;gt; ls
smb: \&amp;gt; get Win10PE_17763.107x64精简.iso
smb: \&amp;gt; q
 还可以挂载 mount -t cifs -o username=administrator,password=123456 //192.168.0.1/tmp /mnt/tmp </description>
    </item>
    
    <item>
      <title>cpp真有点吓人</title>
      <link>https://1980204066.github.io.git/2018/11/30/cpp%E7%9C%9F%E6%9C%89%E7%82%B9%E5%90%93%E4%BA%BA/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/11/30/cpp%E7%9C%9F%E6%9C%89%E7%82%B9%E5%90%93%E4%BA%BA/</guid>
      <description>https://www.newsmth.net/nForum/#!article/CPlusPlus/403674
下面的英文是从教程里摘出来的。然后有点没看懂：make_unique 是cpp14引入的， 在这之前，下面叙述里的 foo 函数要怎么写才可以避免意外的内存泄露呢？ ------------------------------------------------------------- If your compiler does not yet support make_unique() , you can create your unique_ptr as follows. Note that Simple must be mentioned twice: unique_ptr&amp;lt;Simple&amp;gt; mySimpleSmartPtr(new Simple()); Before C++17, you had to use make_unique() not only because you have to specify the type only once, but also because of safety reasons! Consider the following call to a function called foo() : foo(unique_ptr&amp;lt;Simple&amp;gt;(new Simple()), unique_ptr&amp;lt;Bar&amp;gt;(new Bar(data()))); If the constructor of Simple or Bar , or the data() function, throws an exception, depending on your compiler optimizations, it was very possible that either a Simple or a Bar object would be leaked.</description>
    </item>
    
    <item>
      <title>Whenisstd::weak_ptruseful?</title>
      <link>https://1980204066.github.io.git/2018/11/30/Whenisstd::weak_ptruseful?/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/11/30/Whenisstd::weak_ptruseful?/</guid>
      <description>use_countrefer: When is std::weak_ptr useful?
weak_ptr可以判断游荡的指针是否可用。
std::weak_ptr is a very good way to solve the dangling pointer problem. By just using raw pointers it is impossible to know if the referenced data has been deallocated or not. Instead, by letting a std::shared_ptr manage the data, and supplying std::weak_ptr to users of the data, the users can check validity of the data by calling expired() or lock().
应用场景：
  cache objects.</description>
    </item>
    
    <item>
      <title>ld链接器脚本内的locationcounter</title>
      <link>https://1980204066.github.io.git/2018/04/09/ld%E9%93%BE%E6%8E%A5%E5%99%A8%E8%84%9A%E6%9C%AC%E5%86%85%E7%9A%84locationcounter/</link>
      <pubDate>Mon, 09 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2018/04/09/ld%E9%93%BE%E6%8E%A5%E5%99%A8%E8%84%9A%E6%9C%AC%E5%86%85%E7%9A%84locationcounter/</guid>
      <description>https://www.newsmth.net/nForum/#!article/KernelTech/74604
. 是指 memory layout，表示当前偏移量。
对于reloadeble， 。 代表了相邻的session和当前位置的偏移。0-offset
https://forum.osdev.org/viewtopic.php?f=1&amp;amp;t=32840
 . = 0x1111111; /* We are still in the previous section right now. Although if orphan sections are not discarded, we would be in one of those orphan sections instead. */ R_in_same_section = .; /* Relative address in another section by itself is still a relative address in that section, no matter where we use it. */ S_in_first_section = E_inside_current; /DISCARD/ : { *(*); }</description>
    </item>
    
    <item>
      <title>Bios Gpt Pxe Bcdboot Winpe Linux引导</title>
      <link>https://1980204066.github.io.git/posts/2017-08-23-bios-gpt-pxe-bcdboot-winpe-linux%E5%BC%95%E5%AF%BC/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/posts/2017-08-23-bios-gpt-pxe-bcdboot-winpe-linux%E5%BC%95%E5%AF%BC/</guid>
      <description>bios + gpt 折腾   一点注意：
 grub2-install /dev/sda
 把core.img写入Boot Partition.不是sda1.
 references:
 https://www.lightofdawn.org/wiki/wiki.cgi/BIOSBootGPT
 https://blog.csdn.net/sqhxhg/article/details/8456689
BIOS系统：   1、GRUB（2）：需要2MiB”BIOS启动分区”（requires a 2 MiB &amp;#34;BIOS Boot Partition&amp;#34; (EF02 type code in gdisk and bios_grub flag in GNU Parted) in BIOS systems to embed itscore.img file due to lack of post-MBR embed gap in GPT disks. Runtime GPT support in GRUB(2) is provided by thepart_gpt module. SeeGRUB#GPT_specific_instructions for more information）;</description>
    </item>
    
    <item>
      <title>蹭网猫</title>
      <link>https://1980204066.github.io.git/2017/08/22/%E8%B9%AD%E7%BD%91%E7%8C%AB/</link>
      <pubDate>Tue, 22 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2017/08/22/%E8%B9%AD%E7%BD%91%E7%8C%AB/</guid>
      <description>B8000：
echo &amp;#34;start set usb-ether...&amp;#34; setprop sys.usb.config rndis sleep 1 ifconfig rndis0 10.9.8.1 netmask 255.255.255.0 up sleep 1 echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward sleep 1 iptables -P FORWARD ACCEPT iptables -A FORWARD -i usb0 -o wlan0 -j ACCEPT iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE echo &amp;#34;finish setting&amp;#34; HTC:
echo &amp;#34;start set usb-ether...&amp;#34; echo 1 &amp;gt; /sys/class/android_usb/f_rndis/on sleep 1 ifconfig usb0 10.9.9.1 netmask 255.255.255.0 up sleep 1 echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward sleep 1 iptables -P FORWARD ACCEPT iptables -A FORWARD -i usb0 -o wlan0 -j ACCEPT iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE echo &amp;#34;finish setting&amp;#34; cwm.</description>
    </item>
    
    <item>
      <title>mobaxterm is good</title>
      <link>https://1980204066.github.io.git/2016/03/09/moba/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2016/03/09/moba/</guid>
      <description>https://www.52pojie.cn/thread-815661-1-1.html

MobaXterm 是一款Windows系统下全功能终端软件，11月1日官方正式版发布了 v11.0 Build 3816 版本
具体更新说明见官网：https://mobaxterm.mobatek.net/download-home-edition.html
MobaXterm Professional Edition 11.0 Build 3816 正式版
官方安装板：
https://download.mobatek.net/1102018093083521/MobaXterm_Installer_v11... :::
::: {.txt .js-630307 style=&amp;ldquo;display: block;&amp;quot;} https://www.52pojie.cn/thread-815661-1-1.html

MobaXterm 是一款Windows系统下全功能终端软件，11月1日官方正式版发布了 v11.0 Build 3816 版本
具体更新说明见官网：https://mobaxterm.mobatek.net/download-home-edition.html
MobaXterm Professional Edition 11.0 Build 3816 正式版
官方安装板：
https://download.mobatek.net/1102018093083521/MobaXterm_Installer_v11.0.zip
官方便携版：
https://download.mobatek.net/1102018093083521/MobaXterm_Portable_v11.0.zip
百度云下载：
链接：https://pan.baidu.com/s/1tLwqNHKPSaobGQF0a-TPng
提取码：r6ts\
可以上bbs.newsmth.net, 设置 ssh：22 连接， 字体设成GBK 或 ISO-8859-1 https://blog.csdn.net/qq_25646883/article/details/80854217
完美注册机：MobaXterm Keygen v1.1
链接：https://pan.baidu.com/s/1NmhTJBP6ApBlpQ_TeE3VeQ
提取码：339j
MobaXterm Keygen 使用说明：
1. 安装 MobaXterm官方原版
2. 下载注册机，解压后运行&amp;quot;keygen.exe&amp;rdquo;，
3. name：任意，点&amp;quot;Get Version from File&amp;quot;，选择安装目录下的&amp;quot;MobaXterm.</description>
    </item>
    
    <item>
      <title>cygwin64-安装包管理工具</title>
      <link>https://1980204066.github.io.git/2016/03/08/cywin64/</link>
      <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2016/03/08/cywin64/</guid>
      <description>Win10安装cygwin并添加apt-cyg\
cygwin64-安装包管理工具 https://www.aliyun.com/jiaocheng/871909.html
.dos command, install pkg\
 setup-x86_64.exe -q -P curl
setup-x86_64.exe -q -P lynx\
setup-x86_64.exe -q -P wget
 cygwin64 command
 lynx -source rawgit.com/transcode-open/apt-cyg/master...
 Win10安装cygwin并添加apt-cyg\
cygwin64-安装包管理工具 https://www.aliyun.com/jiaocheng/871909.html
.dos command, install pkg\
 setup-x86_64.exe -q -P curl
setup-x86_64.exe -q -P lynx\
setup-x86_64.exe -q -P wget
 cygwin64 command
 lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg &amp;gt; apt-cyg
不成功，到https://www.cnblogs.com/feipeng8848/p/8555648.html 下载\
 https://www.cnblogs.com/feipeng8848/p/8555648.html
修改软件源 apt-cyg --mirror https://mirrors.163.com/cygwin
https://www.cnblogs.com/0616--ataozhijia/p/3653242.html\
apt-cyg安装源为ftp://mirror.mcs.anl.gov，设置为网易镜像源。
apt-cyg update --mirror https://mirrors.</description>
    </item>
    
    <item>
      <title>几款神器软件</title>
      <link>https://1980204066.github.io.git/2016/03/07/software/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2016/03/07/software/</guid>
      <description>http://www.newsmth.net/nForum/#!article/NewSoftware/225130?p=1
应该很多人都用过，并且从中受过益，没有别的意思，只想抛抛砖引引玉。 1、下载神器IDM
可以说只要你能在网页上看到的，都可以下载。新闻视频、直播数据，等等，还可以无限速下载百度云的文件，好用得很。 \
【 在 blueangel332 的大作中提到: 】 : 下载神器IDM 有免费的吗？谢谢 http://idman.ys168.com/ ...\
https://www.newsmth.net/nForum/#!article/NewSoftware/225130?p=1
应该很多人都用过，并且从中受过益，没有别的意思，只想抛抛砖引引玉。 1、下载神器IDM
可以说只要你能在网页上看到的，都可以下载。新闻视频、直播数据，等等，还可以无限速下载百度云的文件，好用得很。 \
【 在 blueangel332 的大作中提到: 】 : 下载神器IDM 有免费的吗？谢谢 https://idman.ys168.com/ \
IDM6.3.2 运行压缩包里的&amp;quot;!绿化.bat&amp;quot;文件 
https://www.52pojie.cn/forum.php?mod=viewthread&amp;amp;tid=823968&amp;amp;page=1
2、文件搜索神器Everything
甩win资源管理器的搜索几条街，2T几十万的文件，都可以在几秒钟内完成索引，世界上最快的文件搜索工具当之无愧。 3、图像无损放大神器PhotoZoom
用他对图片进行任何放大，没有锯齿、较少失真、修复过曝阴影问题、减少JPG的不自然感和杂色、几乎不降低图片品质，并且处理速度还很快，好用得很。 4、文件复制神器FastCopy
还在纠结电脑往移动硬盘拷贝数据很慢的问题吗？你out了。从电脑固态硬盘拷贝几十G的文件到移动硬盘，平均传输速度达到70M/s见过没？没错，就是fastcopy，Windows平台最快的文件复制工具。 \
5. 专业编辑器 010 Editorv9 https://www.sweetscape.com/download/010editor/
010 Editor v9.0 Release! https://www.chinapyg.com/thread-121088-1-1.html
输入一个假的用户名和序列号，会弹出一个用户名或序列号错误的窗口。 再用补丁。\
关于010EditorV9.0的暴力破解 https://bbs.pediy.com/thread-247708.htm\
等等。 www.chinapyg.com
D9BF-18AC-5823-5816-81B6
\
https://www.newsmth.net/nForum/#!article/NewSoftware/225137\
win10 pro 激活码 \

零售版的激活不了，要装vl版的，然后网上各种激活工具https://www.rrkee.com/microsoft/ -- \
 IDM下载器</description>
    </item>
    
    <item>
      <title>Apk Dump 刷机</title>
      <link>https://1980204066.github.io.git/posts/2016-03-05-apk-dump-%E5%88%B7%E6%9C%BA/</link>
      <pubDate>Sat, 05 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/posts/2016-03-05-apk-dump-%E5%88%B7%E6%9C%BA/</guid>
      <description>dump apk   首先得配好java环境， https://www.cnblogs.com/guxiaobei/p/8556586.html
apt-get install default-jre apt-get install default-jdk #去Oracle官方网站下载并安装JDK https://www.oracle.com/technetwork/java/javase/downloads # JDK必须是1.7版本 [[https://www.52pojie.cn/thread-844248-1-1.html]] # 是的，如果用jdk11.0，androidkiller编译后安装不上。  配置环境变量   CLASSPATH -&amp;gt; .;&amp;#34;JAVA_HOME&amp;#34;/lib/dt.jar;&amp;#34;JAVA_HOME&amp;#34;/lib/tools.jar （应该是 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib→ols.jar ？） JAVA_HOME -&amp;gt; C:Program Files\Java\jdk1.7.0_80 PATH -&amp;gt; &amp;#34;JAVA_HOME&amp;#34;/bin;&amp;#34;JAVA_HOME&amp;#34;/lib/tools.jar;
 https://www.cnblogs.com/echomyecho/p/3334617.html
 &amp;#34;classpath&amp;#34;，设置java各个类的路径，&amp;#34;.;%java_home%\lib;%java_home%\lib→ols.jar&amp;#34;。前面的”.”不可少，它代表了我们为自己的java类建立的工作路径，其它的是jdk自带的标准类库路径。
 CLASSPATH的设定，对JAVA的初学者而言是一件棘手的事。所以Sun让JAVA2的JDK更聪明一些。你会发现，在你安装之后，即使完全没有设定CLASSPATH，你仍然能够编译基本的JAVA程序，并且加以执行。
 JAVA_HOME D:\java\jdk1.6.0_32 (JDK安装目录)
 双击系统变量中的Path选项, *C:Program Files\*Java\jdk1.8.0_131\bin
 java -version   apk反编译与破解   https://www.cnblogs.com/JhonKing/p/5106141.html
 java -jar apktool.jar d -f test.apk java -jar apktool_2.3.4.jar d 来电语音报号.</description>
    </item>
    
    <item>
      <title>编码</title>
      <link>https://1980204066.github.io.git/2016/03/04/%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 04 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2016/03/04/%E7%BC%96%E7%A0%81/</guid>
      <description>https://blog.csdn.net/cean1024/article/details/72903069
第一，为什么在运行程序时，在终端按下箭头up down left right 箭头会出现 ^［A^［B^［C^［D
这个跟换键码有关，“escape sequence”实际上是用来生成换码符的关键字的顺序。换码符会告诉打印机将不再打印后面的字符，但是还要将这些字符解释为一类打印机控制码或其他。需要 Escape Sequences 顺序的应用程序通常是早期的 DOS 应用程序、UNIX (R) 应用程序或非常特殊的应用程序。
up - &amp;ldquo;\033[A&amp;rdquo; down - &amp;ldquo;\033[B&amp;rdquo; left - &amp;ldquo;\033[D&amp;rdquo; right - &amp;ldquo;\033[C&amp;rdquo;
\033 = 0x1b = 27 = ^[= Esc 键 ， 也就是说up down left right 这些键，每个都由三个字符组成。
读到键值为 读到27时，再读一个是&#39;[&#39; = 0x5B = 91, 然后再读一个键，若是&amp;rsquo;A&#39; = 0x41 = 65则表示向上的箭头。其他的类似。</description>
    </item>
    
    <item>
      <title>sqlite子查询</title>
      <link>https://1980204066.github.io.git/2015/09/01/sqlite%E5%AD%90%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/09/01/sqlite%E5%AD%90%E6%9F%A5%E8%AF%A2/</guid>
      <description>https://www.yiibai.com/sqlite/sqlite_sub_queries.html
sqlite&amp;gt; SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &amp;gt; 45000) ; insert into revtbl select * from revtbl; DROP VIEW IF EXISTS v_test; CREATE VIEW IF NOT EXISTS v_test AS SELECT * FROM test;
SQLite 3 一些基本的使用 https://www.cnblogs.com/Mr_JinRui/archive/2010/05/12/1733662.html</description>
    </item>
    
    <item>
      <title>god语言</title>
      <link>https://1980204066.github.io.git/2015/08/27/god%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Thu, 27 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/08/27/god%E8%AF%AD%E8%A8%80/</guid>
      <description>目前的计算机语言有c++11，go，D，还有别人实现的一个C++山寨版（已开源），
https://github.com/roundsheep/rpp https://www.newsmth.net/nForum/#!article/CPlusPlus/372449
世界太杂碎了。
应该综合它们的优点成为一种语言，超级模仿c++11， 就叫god吧。
god特性：
1. 是编译执行的，也可以解释执行！使用import， 不再用include。
2. 指针统一使用smart point， new出来的直接就是带有引用计数的，类似boost::shared_ptr，不再使用裸指针。
3. 可以直接执行lisp语言。可以和lisp无缝混合编程。
4. 编译器支持文档和code结合的平坦编程。如同Knuth 在 30 年前提出的 literate programming。
5. 支持内嵌函数，如同passcal. 支持code block变量，类似c 的宏定义，可以让debug跟踪进去。
6. 优化模板编程和类型推导和定义。
god语言实现以后，应该用它来重写linux kernel，这样code量会大大减少，100万的code估计会缩小一半。
god kernel特性：
1. kernel使用面向对象的编程。
2. 使用的库函数应该和应用层的尽量统一。
3. kernel支持coroutine，类似把switch_to暴露给用户，增加yield等系统调用。用户库实现coroutine太猥琐了。</description>
    </item>
    
    <item>
      <title>使用boost</title>
      <link>https://1980204066.github.io.git/2015/03/06/%E4%BD%BF%E7%94%A8boost/</link>
      <pubDate>Fri, 06 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/03/06/%E4%BD%BF%E7%94%A8boost/</guid>
      <description>Table of Contents  使用boost执行base64解码 Serialization 可变长度的网络消息数据打包  使用boost执行base64解码 https://microcai.org/2013/03/28/boost-base64.html
base64 编码最初是为了电子邮件开发的。因为电子邮件是个文本协议，不能传输二进制数据，甚至中文也无法进行传输。只能传输ascii编码的文本。这样一来就诞生了多种将二进制数据编码到ascii里的编码方案，base64是其中之一。
base64是一种非常简单的编码，只要进行一次迭代即可完成解码。
什么？一次迭代？？？
这就让我们有机会借助 Boost 提供的迭代器非常简洁的写出base64解码器。
Boost 提供了一个叫 boost::archive::iterators::binary/from/base64 的迭代器。但是直接使用它并不能完成 base64解码。
还应该外面再套一层 archive::iterators::transformwidth以 6bit 为单位转换到 8bit。
typedef archive::iterators::transform_width&amp;lt;archive::iterators::binary_from_base64, 8, 6, char&amp;gt; base64decodeIterator;  那么这个就应该是用于解码的 base64decodeIterator
但是，稍等。如果用来解码电子邮件里的东西，会经常出异常，说有不能允许的字符出现在了base64输入里。
为什么呢？ 因为电子邮件以 78个字符断行了。也就是出现了base64里不允许的 CRLF。
那么，怎么办？ 解码前先替换删除 CRLF ?
非也非也，这么做是愚蠢的哦，因为我们要的就是一次迭代的效果。 所以，archive::iterators::binary/from/base64 使用的是 const char * 这个迭代器，对吧，我们改一下，使用 boost::filteriterator这个迭代器。过滤掉非base64编码字符。
boost::filteriterator需要使用一个模板参数，参数是一个过滤用的仿函数。
于是我们写一个
struct is_base64_char { bool operator()(char x) { return boost::is_any_of(&amp;quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/=&amp;quot;)(x); } };  然后使用 boost::filter/iteratorbase64/char, const char*&amp;gt; 作为 archive::iterators::binaryfrombase64的迭代器，就形如</description>
    </item>
    
    <item>
      <title>从std::cout和endl说起</title>
      <link>https://1980204066.github.io.git/2015/02/06/%E4%BB%8Estd::cout%E5%92%8Cendl%E8%AF%B4%E8%B5%B7/</link>
      <pubDate>Fri, 06 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/02/06/%E4%BB%8Estd::cout%E5%92%8Cendl%E8%AF%B4%E8%B5%B7/</guid>
      <description>https://www.cnblogs.com/lihaozy/archive/2012/05/09/2491791.html https://blog.csdn.net/hityct1/article/details/4082832
正文  问题是这样的&amp;hellip;&amp;hellip;
相信下面这个程序凡是会写C++程序的同仁都认得，估计学会的第一个C++程序就是它了吧：
//---------------------------------------------- // 水之真谛 // https://blog.csdn.net/FantasiaX //---------------------------------------------- #include int main(int argc, char *argv[]) { std::cout &amp;lt;&amp;lt; &amp;quot;Hello, World.&amp;quot; &amp;lt;&amp;lt; std::endl; return 0; }  我会写一点C语言的程序，于是在写这个程序的时候就对很多东西&amp;quot;想当然&amp;quot;了。比如对于操作符&amp;quot;&amp;lt;&amp;lt;&amp;quot;，在心里一直是与C语言的printf()函数对应起来的&amp;mdash;&amp;mdash;认为它就是封装进了ostream对象中的printf()函数。既然是这样，那么对于&amp;quot;endl&amp;quot;，自然就&amp;quot;想当然&amp;quot;地认为它是&amp;quot;n&amp;quot;了。
 突然有一天，在Visual Studio弹出的代码自动完成窗口中发现，endl不是一个成员变量（如果它代表一个字符，那么理应是一个字符类型的成员变量）而是一个成员函数！大脑中立刻蹦出一个解释：或许endl函数的返回值是字符&amp;quot;n&amp;quot;吧？可是这个答案存活了不到一秒钟就被否定了&amp;mdash;&amp;mdash;如果想让一个函数执行从而得到它的返回值，应该是调用这个函数，所以写法应该是&amp;quot;std::endl()&amp;ldquo;而不是&amp;quot;std::endl&amp;quot;。写成&amp;quot;std::endl&amp;ldquo;是将函数名放在这里,并不是在调用这个函数。哈~~脑子里的概念开始互相打架了~~
  因为问题是出在了endl上，所以一直在查endl的定义&amp;mdash;&amp;mdash;结果除了发现MSDN里有个Bug之外，一无所获L
MSDN里是这样声名的：
template class&amp;lt;_Elem, _Tr&amp;gt; basic_ostream&amp;lt;_Elem, _Tr&amp;gt;&amp;amp; endl( basic_ostream&amp;lt;_Elem, _Tr&amp;gt;&amp;amp; _Ostr );
红色标记的地方写错了:p
C++ ISO文档里是这样声名的：
template basic_ostream&amp;amp; endl(basic_ostream&amp;amp; os);
按MSDN里模板的&amp;quot;写法&amp;quot;根本编译不过去，呵呵。
 不过，MSDN里的说明还是非常有用的&amp;mdash;&amp;mdash;Terminates a line and flushes the buffer. 可是函数的功能是&amp;quot;结束一行并冲洗缓冲区&amp;rdquo;，如果想执行这个功能，应该是调用这个函数、应该写endl()而不是endl啊&amp;hellip;&amp;hellip;看来问题又绕回去了。于是这事儿就放下了。
 今天遇到高手Sidney，又问起了这个问题。Sidney是研究过这个问题的，虽然没有给出我答案，但他提到这么一句话&amp;mdash;&amp;mdash;&amp;quot;&amp;lt;&amp;lt;&amp;ldquo;操作符是被重载过的，可以接收一个函数作为参数。正好前几天我在写《深入浅出话回调》的时候写过类似的程序，经Sidney一点拨，顿时感觉豁然开朗。很快问题的答案就找到了&amp;mdash;&amp;mdash;
 1. 先查看的成员，找到一个全局对象cout 2. 查看cout对象，发现它是ostream的一个实例 3.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11语法甜点</title>
      <link>https://1980204066.github.io.git/2015/01/30/C&#43;&#43;11%E8%AF%AD%E6%B3%95%E7%94%9C%E7%82%B9/</link>
      <pubDate>Fri, 30 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/01/30/C&#43;&#43;11%E8%AF%AD%E6%B3%95%E7%94%9C%E7%82%B9/</guid>
      <description>https://www.cnblogs.com/hujian/archive/2012/02/20/2358853.html</description>
    </item>
    
    <item>
      <title>Git代理设置与访问Github</title>
      <link>https://1980204066.github.io.git/2015/01/29/Git%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AEGithub/</link>
      <pubDate>Thu, 29 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/01/29/Git%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AEGithub/</guid>
      <description>https://blog.csdn.net/bluishglc/article/details/37807501
由于目前工作的网络环境有着很严格的限制，可以说最近在通过代理访问Github上颇费了一些周折，也积累了一些相关的经验，觉得有必要备忘一下。本着&amp;quot;不重新发明轮子&amp;quot;的宗旨，本文不会对Github代理设置的每一个细节进行赘述，文中会给出现成的参考文章，这里要做的是针对一些重要的问题进行解释和补充，相信一定能给遇到同样问题朋友以帮助。本文原文出处:https://blog.csdn.net/bluishglc/article/details/37807501 严禁任何形式的转载，否则将委托CSDN官方维护权益！
1. 别折腾了，请先屏蔽NTLM验证！
首先，如果你的网络代理使用的是NTLM验证，不要作任何无谓的&amp;quot;挣扎&amp;quot;，请先安装Cntlm，建立一个无须身份验证的普通HTTP代理，因为目前版本的GIT不支持NTLM验证的代理，不先借助Cntlm屏蔽掉NTLM验证，后续的任何工作都是无意义的。关于Cntlm的安装和配置请参考：https://blog.csdn.net/bluishglc/article/details/37600773
**2. Git代理配置走起 **
关于Git代理的配置请参考：https://jixiuf.github.io/git/git-proxy-on-windows.html 这里对文中提到的ssh的config文件简单地解释一下，这个文件主要是保存一些经常访问的目标主机的连接配置，很像Putty里保存的session。config文件的结构是是以Host开头的配置项是作为一组，Host项之后到下一个Host之前的所以配置项都是针对这个Host配置的！另外，文中config文件提到的connect是一种代理转发工具，对一个简单的命令行工具不太可能设计如何配置代理，或者像SSH这样为了保证程序本身功能的单一，把代理配置委托第三方工具实现，这就是connect的作用。
3. https://？可以！git://？没门！
安装配置好Cntlm，参看前面的文章进行配置，我们就可以在Github上检入检出https://描述的repository了，如果你尝试使用git://或git@github.com格式的地址访问，则在某些代理环境下可能会报出如下错误：
HTTP/1.1 502 Proxy Error ( The specified Secure Sockets Layer (SSL) port is not allowed. Forefront TMG is not configured to allow SSL requests from this port. Most Web browsers use port 443 for SSL requests. )
引起这一问题的原因是git://使用的9418端口以及基于SSH的git@github.com格式的地址使用的22端口在你的网络环境里(特别是代理服务端)被防火墙屏蔽了。这是极为常见的，大多数的代理环境基于安全考虑，会屏蔽除80(http)和443(https)之外的端口。那这是否意味着我们就不能在这种网络环境里使用git://或git@github.com格式的地址呢？请继续看下文。
** 4. 幸好有你：SSH over the HTTPS port**
虽然可以在Github上使用HTTPS协议push代码（使用的是用户名在Github上的用户名和密码），但通常来说，使用SSH检出和提交代码是更为安全，更适合团队开发，那么怎么解决前文提到的问题呢？对此，Github通过将ssh的连接端口指定为https使用的443，使用了另外一个主机名：ssh.github.com来解决这一问题，这样我们可以通过大多数代理服务器允许的443端口，使用SSH访问Github了，这一点在前面参考文章中提到的config文件里也配置过了，就是Host为ssh.github.com的部分，关于这部分的说明和配置，Github的官方帮助文档也有说明：https://help.github.com/articles/using-ssh-over-the-https-port。这里我只想说一下如何验证配置已经成功，显然，只要我们能通过SSH登入目标主机就表明配置正确了：
方法一：像我们前面提到的参考文章，它把ssh.github.com的配置参数写进了ssh的config文件，这样可以在命令行工具中使用
ssh -T -p 443 git@ssh.github.com
就能验证config文件配置是否正确了，成功登入后提示：
{real_src=&amp;ldquo;https://img.blog.csdn.net/20140714203047421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1aXNoZ2xj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&amp;quot; style=&amp;ldquo;max-width:500px;&amp;quot;}
方法二：如果在配置这些参数之前我们不能确定它们的正确性，我们可以先通过命令行的方式来指定这些参数，待验证通过后把这些参数写入到config文件中。此时的命令要这样写：</description>
    </item>
    
    <item>
      <title>给Git或者APT设置goagent代理</title>
      <link>https://1980204066.github.io.git/2015/01/28/%E7%BB%99Git%E6%88%96%E8%80%85APT%E8%AE%BE%E7%BD%AEgoagent%E4%BB%A3%E7%90%86/</link>
      <pubDate>Wed, 28 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/01/28/%E7%BB%99Git%E6%88%96%E8%80%85APT%E8%AE%BE%E7%BD%AEgoagent%E4%BB%A3%E7%90%86/</guid>
      <description> 最近使用git从github上clone代码，总是失败，奔溃了快。还有ubuntu连apt-get update都执行不了，有的时候都装不了git，就快骂娘了。可惜在这样一个环境下，只能靠自己搞定了，设置代理是比较好的方式
 引用https://yansu.org/2013/05/20/set-proxy-for-git-or-apt.html 安装goagent 这个教程网上很多，放狗一搜即可。
不过网上goagent教程里讲的大部分是给浏览器用的。其实goagent是监听了本地的8087端口，其实任何程序都可以利用这个端口，只要设置好即可。
设置git代理 直接在终端输入
 export https_proxy=&amp;quot;127.0.0.1:8087&amp;quot; export http_proxy=&amp;quot;127.0.0.1:8087&amp;quot; git config --global http.sslVerify false  这样git clone就是走代理了，其实这个设置完以后apt-get的操作也是通过代理的了
设置apt-get代理 上面的方法也可以直接使apt代理，如果不想设置环境变量，可以使用下面命令
 sudo apt-get-o Acquire::http::proxy=&amp;quot;https://127.0.0.1:8087/&amp;quot; update  </description>
    </item>
    
    <item>
      <title>C&#43;&#43;14的returntypededuction&amp;</title>
      <link>https://1980204066.github.io.git/2015/01/26/C&#43;&#43;14%E7%9A%84returntypededuction&amp;/</link>
      <pubDate>Mon, 26 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/01/26/C&#43;&#43;14%E7%9A%84returntypededuction&amp;/</guid>
      <description>https://www.newsmth.net/nForum/#!article/CPlusPlus/374960
若干年前实现了一个 C++ 序列化库，以前一直纠结于一种优化无法（自动）实现： struct A { int a1, a2; }; struct B { int b1, b2; }; struct C { A ca; B cb; }; struct D { std::set d; }; DATA_IO_LOAD_SAVE_E(A, &amp;amp;a1 &amp;amp;a2) // 序列化 A 的 a1, a2 成员，下同 DATA_IO_LOAD_SAVE_E(B, &amp;amp;b1 &amp;amp;b2) DATA_IO_LOAD_SAVE_E(C, &amp;amp;ca &amp;amp;cb) DATA_IO_LOAD_SAVE_E(D, &amp;amp;d) // stl 容器也可以序列化  如果使用 NativeDataInput/Output, 只能自动推断出 A, B 可以直接 memcpy，无法推断出 C 也可以 memcpy，当然，任何情况下 D 肯定都是 无法 memcpy 的  现在有了 return type deduction, C memcpy 的问题就解决了  参考链接： https://www.</description>
    </item>
    
    <item>
      <title>开源一个重剑无锋大巧不工</title>
      <link>https://1980204066.github.io.git/2015/01/26/%E5%BC%80%E6%BA%90%E4%B8%80%E4%B8%AA%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5/</link>
      <pubDate>Mon, 26 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://1980204066.github.io.git/2015/01/26/%E5%BC%80%E6%BA%90%E4%B8%80%E4%B8%AA%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5/</guid>
      <description>https://www.newsmth.net/nForum/#!article/CPlusPlus/374960 https://github.com/rockeet/nark-rpc  RPC(Remote Procedure Call) on top of nark-serialization  +++++++++++++++++++++++++++++++++++++  https://github.com/rockeet/nark-serialization  An easy, fast, small, portable C++ object serialization framework  Features:  Declarative syntax, Easy to use, Easy to integrate  Fast at runtime, Fast at compile time  Serialized data is small, Compiled code is small  Support STL containers &amp;amp; types  Can serialize to BigEndian/LittleEndian in any platform  Support variant int/uint encoding  Optional serialization version control  More and more.</description>
    </item>
    
  </channel>
</rss>
